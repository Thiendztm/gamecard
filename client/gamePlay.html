<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Touhou FM: Battle Card - Game</title>
    <link rel="stylesheet" href="css/gameplay.css">
    <style>
    /* Game Result Overlay */
    .game-result-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      animation: fadeIn 0.5s ease-in-out;
    }
    
    .result-container {
      background: linear-gradient(135deg, #1e293b, #334155);
      border: 2px solid #475569;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      max-width: 500px;
      width: 90%;
      animation: slideUp 0.6s ease-out;
    }
    
    .result-title {
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .result-title.win { color: #10b981; }
    .result-title.lose { color: #ef4444; }
    .result-title.draw { color: #f59e0b; }
    
    .result-details {
      font-size: 18px;
      color: #94a3b8;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    
    .result-stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #e2e8f0;
    }
    
    .stat-label {
      font-size: 14px;
      color: #94a3b8;
      margin-top: 5px;
    }
    
    .result-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 30px;
    }
    
    .result-btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .result-btn.primary {
      background: #3b82f6;
      color: white;
    }
    
    .result-btn.secondary {
      background: #6b7280;
      color: white;
    }
    
    .result-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideUp {
      from { 
        opacity: 0;
        transform: translateY(50px) scale(0.9);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    </style>
  <script src="/socket.io/socket.io.js"></script>
  <script src="/scripts/sound.js"></script>
  <script src="/scripts/bgm.js"></script>
  </head>
  <body>
    <!-- Game Result Overlay -->
    <div id="game-result-overlay" class="game-result-overlay">
      <div class="result-container">
        <div id="result-title" class="result-title">CHI·∫æN TH·∫ÆNG!</div>
        <div id="result-details" class="result-details">
          K·∫øt th√∫c l∆∞·ª£t 10. B·∫°n ƒë√£ chi·∫øn th·∫Øng!
        </div>
        <div class="result-stats">
          <div class="stat-item">
            <div id="your-final-hp" class="stat-value">100</div>
            <div class="stat-label">HP c·ªßa b·∫°n</div>
          </div>
          <div class="stat-item">
            <div id="op-final-hp" class="stat-value">50</div>
            <div class="stat-label">HP ƒë·ªëi th·ªß</div>
          </div>
          <div class="stat-item">
            <div id="final-turn" class="stat-value">10</div>
            <div class="stat-label">S·ªë l∆∞·ª£t</div>
          </div>
        </div>
        <div class="result-buttons">
          <button id="play-again-btn" class="result-btn primary">Ch∆°i l·∫°i</button>
          <button id="back-to-menu-btn" class="result-btn secondary">V·ªÅ Menu</button>
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <div id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <button class="tab-btn active" data-tab="chat">Chat</button>
        <button class="tab-btn" data-tab="events">Event Log</button>
      </div>
      <div class="sidebar-content">
        <div id="chat-tab" class="tab-content active">
          <div id="chat-messages" class="messages-container"></div>
          <div class="chat-input-container">
            <input type="text" id="chat-input" placeholder="Nh·∫≠p tin nh·∫Øn..." maxlength="200">
            <button id="send-chat" class="send-btn">G·ª≠i</button>
          </div>
        </div>
        <div id="events-tab" class="tab-content">
          <div id="event-messages" class="messages-container"></div>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="wrap">
        <h2>Touhou FM: Battle Card</h2>

      <!-- LOBBY -->
      <div id="screen-lobby" class="card">
        <div class="lobby-header">
          <h3>Chu·∫©n b·ªã tr·∫≠n ƒë·∫•u v·ªõi Bot</h3>
          <div class="match-info">
            <div class="player-info">
              <img id="player-avatar" class="lobby-avatar" src="../assets/reimu2.png" alt="Player"/>
              <div class="player-details">
                <div class="player-name" id="player-name">ƒêang t·∫£i...</div>
                <div class="player-character">
                  <select id="character" class="character-select">
                    <option value="Reimu">Reimu (Heal +20 on special)</option>
                    <option value="Marisa">Marisa (Attack +25 on special)</option>
                  </select>
                </div>
              </div>
            </div>
            <div class="vs-text">VS</div>
            <div class="bot-info">
              <img id="bot-avatar" class="lobby-avatar" src="../assets/marisa2.png" alt="Bot"/>
              <div class="bot-details">
                <div class="bot-name" id="bot-name">AI Bot</div>
                <div class="bot-difficulty" id="bot-difficulty">ƒê·ªô kh√≥: Trung b√¨nh</div>
                <div class="op-status" id="op-status" style="margin-top:4px;font-size:13px;color:#94a3b8;display:none;">ƒêang ch·ªù...</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="action-buttons">
          <div style="display:flex;flex-direction:column;gap:12px;align-items:center;">
            <div style="display:flex;gap:16px;align-items:center;">
              <span class="muted">Ch·ªçn deck:</span>
              <select id="deck-selector" style="min-width:200px;padding:8px;">
                <option value="">-- Ch·ªçn deck ƒë·ªÉ ch∆°i --</option>
              </select>
              <button id="refresh-decks" class="btn btn-secondary">‚ü≥</button>
            </div>
            <button id="start-match" class="btn btn-success" disabled>B·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u</button>
          </div>
        </div>
        
        <div class="muted" id="lobby-msg" style="margin-top:8px;"></div>
        <div class="row" style="margin-top:16px;">
          <button id="back-to-menu" class="btn btn-secondary">Quay l·∫°i Menu</button>
        </div>
      </div>

      <!-- DECK BUILDER -->
      <div id="screen-deck" class="card" style="display:none;">
        <h3>Deck Builder (t·ªëi ƒëa 15 l√°, m·ªói lo·∫°i t·ªëi ƒëa 6)</h3>
        <div class="row" style="gap:16px;align-items:center;margin-bottom:8px;flex-wrap:wrap">
          <input id="deck-name" type="text" placeholder="T√™n deck..." style="width:180px;" maxlength="20">
          <button id="save-deck" class="btn">L∆∞u deck</button>
          <button id="new-deck" class="btn btn-secondary">Deck m·ªõi</button>
        </div>
        <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">
          <span class="muted small">Deck ƒë√£ l∆∞u:</span>
          <select id="deck-list-select" style="min-width:180px;"></select>
          <button id="load-deck" class="btn btn-secondary">N·∫°p</button>
          <button id="delete-deck" class="btn btn-secondary">X√≥a</button>
        </div>
        <div class="row small" style="flex-wrap:wrap;gap:10px">
          <div class="tag">Attack: <span id="cnt-attack">0</span></div>
          <div class="tag">Defend: <span id="cnt-defend">0</span></div>
          <div class="tag">Heal: <span id="cnt-heal">0</span></div>
          <div class="tag">Curse: <span id="cnt-curse">0</span></div>
          <button id="submit-deck" class="btn">X√°c nh·∫≠n Deck</button>
        </div>
        <div class="row" style="gap:30px;align-items:flex-start;flex-wrap:wrap;justify-content:center;margin-top:16px;">
          <div style="min-width:480px;">
            <div class="muted small" style="margin-bottom:6px;">K√©o th·∫£ l√° b√†i v√†o deck c·ªßa b·∫°n:</div>
            <div id="card-samples" class="hand" style="min-height:150px;">
              <div class="cardbtn" draggable="true" data-type="attack" title="Attack"></div>
              <div class="cardbtn" draggable="true" data-type="defend" title="Defend"></div>
              <div class="cardbtn" draggable="true" data-type="heal" title="Heal"></div>
              <div class="cardbtn" draggable="true" data-type="curse" title="Curse"></div>
            </div>
          </div>
          <div style="min-width:480px;">
            <div class="muted small" style="margin-bottom:6px;">Deck c·ªßa b·∫°n (k√©o ra ngo√†i ƒë·ªÉ x√≥a):</div>
            <div id="deck-drop" class="hand" style="min-height:150px;border:2px dashed #334155;background:rgba(52,60,90,0.12);"></div>
          </div>
        </div>
        <div class="muted small">Danh s√°ch l√°: <span id="deck-list"></span></div>
        <div class="muted" id="deck-error" style="color:#ff8b8b;"></div>
      </div>

      <!-- GAME -->
      <div id="screen-game" class="card" style="display:none;">
        <div class="board">
          <div class="opp-backs" id="opp-backs">
            <div class="back"></div><div class="back"></div><div class="back"></div><div class="back"></div><div class="back"></div>
          </div>

          <!-- LEFT: YOU -->
          <div class="side" id="you-side">
            <img id="you-avatar" class="avatar" src="../assets/reimu.png" alt="You"/>
            <div class="bar" style="width:100%">
              <div><strong id="you-name">YOU</strong></div>
              <div><span class="special-pill special-ready" id="you-special-pill">SPECIAL SKILL</span></div>
            </div>
            <div class="hpbar"><div id="you-hp" class="hpfill" style="width:100%"></div></div>
            <div style="font-size:13px">HP: <span id="you-hp-text">100</span> | <span class="shieldline">Shield:</span> <span id="you-shield">0</span></div>
          </div>

          <!-- CENTER: TURN/TIMER + REVEAL -->
          <div class="center-info">
            <div class="badges">
              <span class="tag">Turn: <span id="turn">1</span></span>
              <span class="tag">Pha: <span id="phase">play</span></span>
            </div>
            <div class="timer" id="timer">20s</div>
            <div class="reveal" id="reveal"></div>
            <div class="muted last-played">L√° ƒë√£ ch∆°i: <span id="last-played"></span></div>
          </div>

          <!-- RIGHT: OPPONENT -->
          <div class="side" id="op-side">
            <img id="op-avatar" class="avatar" src="../assets/marisa.png" alt="Opponent"/>
            <div class="bar" style="width:100%">
              <div><strong id="op-name">OPPONENT</strong></div>
              <div><span class="special-pill" id="op-special-pill">SPECIAL SKILL</span></div>
            </div>
            <div class="hpbar"><div id="op-hp" class="hpfill" style="width:100%"></div></div>
            <div style="font-size:13px">HP: <span id="op-hp-text">100</span> | <span class="shieldline">Shield:</span> <span id="op-shield">0</span></div>
          </div>

          <!-- BOTTOM: HAND -->
          <div class="bottom-area">
            <h3 class="center" style="margin:6px 0 10px">Tay b√†i c·ªßa b·∫°n</h3>
            <div class="hand-container">
              <button id="special-skill-btn" class="special-btn">
                <img src="../assets/btnSK.png" alt="Special Skill">
              </button>
              <div id="hand" class="hand"></div>
            </div>
            <div class="center muted small" id="deck-meta" style="margin-top:10px"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const socket = io();
      const rules = { HP_START:100, TURN_LIMIT:10, TURN_SECONDS:20, HAND_SIZE:5, DECK_MAX:15, TYPE_LIMIT:6 };
      const $ = id=>document.getElementById(id);
      const lobby=$("screen-lobby"), deck=$("screen-deck"), game=$("screen-game");
      
      // Special skill state
      let specialSkillActive = false;
      let specialSkillUsed = false;
      
      // Special skill button functions
      function updateSpecialButtonState() {
        const specialBtn = $("special-skill-btn");
        if (!specialBtn) return;
        
        if (specialSkillUsed) {
          specialBtn.classList.add('disabled');
          specialBtn.classList.remove('active');
        } else if (specialSkillActive) {
          specialBtn.classList.add('active');
          specialBtn.classList.remove('disabled');
        } else {
          specialBtn.classList.remove('active', 'disabled');
        }
      }

      // Back to menu button
      $("back-to-menu").onclick = () => {
        // Check if currently in game, go back to lobby
        if (game.style.display !== "none") {
          game.style.display = "none";
          lobby.style.display = "";
        } else {
          // If in lobby/deck, go to main menu
          window.location.href = '/main_menu.html';
        }
      };

      // Initialize lobby
      window.onload = function() {
        // Random background for game room
        const backgrounds = [
          '../assets/background/bg3.png',
          '../assets/background/bg4.jpg', 
          '../assets/background/bg5.png',
          '../assets/background/bg6.jpg',
          '../assets/background/bg7.jpg',
          '../assets/background/background1.jpg',
          '../assets/background/background2.jpg'
        ];
        const randomBg = backgrounds[Math.floor(Math.random() * backgrounds.length)];
        document.body.style.backgroundImage = `url('${randomBg}'), linear-gradient(45deg, rgba(11,15,22,0.8), rgba(26,36,64,0.9))`;
        document.body.style.backgroundSize = 'cover, auto';
        document.body.style.backgroundPosition = 'center, center';
        document.body.style.backgroundRepeat = 'no-repeat, no-repeat';
        document.body.style.backgroundAttachment = 'fixed, scroll';
        
        const user = sessionStorage.getItem('user');
        if (!user) {
          window.location.href = 'index.html';
          return;
        }
        
        const userData = JSON.parse(user);
        $("player-name").textContent = userData.username || "Player";
        
        // Load saved avatar if available
        const savedAvatar = sessionStorage.getItem('userAvatar');
        if (savedAvatar) {
          $("player-avatar").src = savedAvatar;
        }
        
        // Get bot difficulty from sessionStorage (set when creating AI room)
        // X√°c ƒë·ªãnh ch·∫ø ƒë·ªô tr·∫≠n: 'ai' ho·∫∑c 'pvp'
        const matchMode = sessionStorage.getItem('matchMode') || 'ai';
        window.__MATCH_MODE__ = matchMode; // debug/global
        if (matchMode === 'ai') {
          const botDifficulty = sessionStorage.getItem('botDifficulty') || 'medium';
          const difficultyNames = {
            'easy': 'D·ªÖ - Th√≠ch h·ª£p cho ng∆∞·ªùi m·ªõi',
            'medium': 'Trung b√¨nh - Chi·∫øn thu·∫≠t c∆° b·∫£n', 
            'hard': 'Kh√≥ - Chi·∫øn thu·∫≠t n√¢ng cao',
            'expert': 'Chuy√™n gia - R·∫•t th√°ch th·ª©c'
          };
          $("bot-difficulty").textContent = `ƒê·ªô kh√≥: ${difficultyNames[botDifficulty] || difficultyNames['medium']}`;
          $("screen-lobby").querySelector('h3').textContent = 'Chu·∫©n b·ªã tr·∫≠n ƒë·∫•u v·ªõi Bot';
        } else {
          // PvP mode: ·∫®n th√¥ng tin ƒë·ªô kh√≥ bot
          const botDiffEl = $("bot-difficulty");
          if (botDiffEl) botDiffEl.parentElement.style.display = 'none';
          $("screen-lobby").querySelector('h3').textContent = 'Chu·∫©n b·ªã tr·∫≠n ƒë·∫•u v·ªõi Ng∆∞·ªùi';
          // PvP: placeholder opponent info + rename action button
          $("bot-name").textContent = 'ƒê·ªëi th·ªß';
          $("start-match").textContent = 'S·∫µn s√†ng';
        }
        
        // Setup special skill button event listener
        setTimeout(() => {
          const specialBtn = $("special-skill-btn");
          if (specialBtn) {
            specialBtn.onclick = () => {
              if (!specialSkillUsed) {
                specialSkillActive = !specialSkillActive;
                updateSpecialButtonState();
              }
            };
          }
        }, 100);
        
        // Initialize sidebar
        initSidebar();

        // Random BGM cho tr·∫≠n (m·ªói tr·∫≠n ch·ªçn 1 b√†i ng·∫´u nhi√™n) ‚Äì ch·ªâ √°p d·ª•ng trong tr·∫≠n, menu kh√¥ng random
        if(window.BGM){
          BGM.init().then(()=>{
            // Lu√¥n b·∫≠t shuffle trong game
            BGM.setShuffle(true);
            if(!BGM.isPlaying){
              BGM.playRandom({fadeInMs:800});
            } else {
              // N·∫øu ƒë√£ ph√°t s·∫µn t·ª´ menu (track c·ªë ƒë·ªãnh), chuy·ªÉn sang random cho l∆∞·ª£t ti·∫øp theo
              BGM.playRandom({crossfadeMs:600});
            }
          }).catch(()=>{});
        }
        
        // Add welcome messages
        addEventLog('K·∫øt n·ªëi th√†nh c√¥ng ƒë·∫øn server');
        addChatMessage('System', 'Ch√†o m·ª´ng ƒë·∫øn v·ªõi Touhou FM: Battle Card!');
        
        // Load available decks into selector
        loadDeckSelector();
      };

      // Load deck selector
      function loadDeckSelector() {
        const decks = JSON.parse(localStorage.getItem('savedDecks')||'{}');
        const selector = $("deck-selector");
        selector.innerHTML = '<option value="">-- Ch·ªçn deck ƒë·ªÉ ch∆°i --</option>';
        Object.keys(decks).forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          selector.appendChild(opt);
        });
      }

      // Refresh decks button
      $("refresh-decks").onclick = () => {
        loadDeckSelector();
        $("lobby-msg").textContent = "ƒê√£ t·∫£i l·∫°i danh s√°ch deck!";
      };

      // Deck selector change
      $("deck-selector").onchange = () => {
        const selector = $("deck-selector");
        const startBtn = $("start-match");
        if (selector.value) {
          startBtn.disabled = false;
          $("lobby-msg").textContent = `ƒê√£ ch·ªçn deck: ${selector.value}`;
        } else {
          startBtn.disabled = true;
          $("lobby-msg").textContent = "";
        }
      };

      // Start match button  
      $("start-match").onclick = () => {
        console.log("Start match button clicked");
        const name = $("player-name").textContent || "Player";
        const character = $("character").value || "Reimu";
        const playerAvatar = $("player-avatar").getAttribute('src');
        
        // Get selected deck
        const selector = $("deck-selector");
        const selectedDeckName = selector.value;
        console.log("Selected deck:", selectedDeckName);
        if (!selectedDeckName) {
          alert("Vui l√≤ng ch·ªçn deck ƒë·ªÉ ch∆°i!");
          return;
        }
        
        const decks = JSON.parse(localStorage.getItem('savedDecks')||'{}');
        const selectedDeck = decks[selectedDeckName];
        console.log("Deck data:", selectedDeck);
        if (!selectedDeck) {
          alert("Deck kh√¥ng t·ªìn t·∫°i!");
          return;
        }
        
        // Force leave any existing card game rooms before starting new match
        socket.rooms.forEach(roomId => {
          if (roomId.startsWith('cardgame-') || roomId.startsWith('airoom-')) {
            socket.leave(roomId);
            console.log('Force left room before new match:', roomId);
          }
        });
        
        addEventLog(`B·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u v·ªõi deck: ${selectedDeckName}`);
        addEventLog(`Nh√¢n v·∫≠t: ${character}`);
        
        // Save selected deck for the match
        sessionStorage.setItem('playerDeck', JSON.stringify(selectedDeck));
        
        // Reset game state before starting new game
        myId = null;
        last = {yhp:100, ohp:100, yshield:0, oshield:0, phase:"play", turn:0, yCurse:0, oCurse:0};
        const matchMode = window.__MATCH_MODE__ || sessionStorage.getItem('matchMode') || 'ai';
        console.log("Match mode:", matchMode);
        const isBotGame = matchMode === 'ai';
        if (isBotGame) {
          console.log("Emitting cardgame/join for AI game");
          socket.emit("cardgame/join", {name, character, isBot: true, avatar: playerAvatar});
          $("lobby-msg").textContent = "ƒêang kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u v·ªõi bot...";
        } else {
          console.log("Emitting cardgame/join for PvP game");
          socket.emit("cardgame/join", {name, character, isBot: false, avatar: playerAvatar});
          $("lobby-msg").textContent = "ƒêang gh√©p ƒë·ªëi th·ªß...";
        }
      };
      
      socket.on("cardgame/waiting",()=>{
        console.log("Received cardgame/waiting event");
        $("lobby-msg").textContent="ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c...";
        addEventLog("ƒêang ch·ªù ƒë·ªëi th·ªß...");
      });
      
      socket.on("cardgame/matched",(info)=>{
        console.log("Received cardgame/matched event:", info);
        // Reset game state for new match
        last = {yhp:100, ohp:100, yshield:0, oshield:0, phase:"deckbuild", turn:0, yCurse:0, oCurse:0};
        specialSkillActive = false;
        specialSkillUsed = false;
        updateSpecialButtonState();
        
        // Reset UI elements
        $("turn").textContent = "1";
        $("phase").textContent = "deckbuild";
        $("timer").textContent = "20s";
        $("last-played").textContent = "";
        $("reveal").innerHTML = "";
        
        // Clear event log for new match
        const eventMessages = document.getElementById('event-messages');
        if (eventMessages) eventMessages.innerHTML = '';
        
        // Clear chat messages for new match  
        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) chatMessages.innerHTML = '';
        
        const mode = window.__MATCH_MODE__ || sessionStorage.getItem('matchMode') || 'ai';
        addEventLog(mode==='ai'?"ƒê√£ t√¨m th·∫•y Bot! Chu·∫©n b·ªã v√†o game...":"ƒê√£ gh√©p v·ªõi ng∆∞·ªùi ch∆°i! Chu·∫©n b·ªã v√†o game...");
        addChatMessage('System', 'B·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u m·ªõi!');
        const savedDeck = sessionStorage.getItem('playerDeck');
        if (savedDeck) {
          const deckArray = JSON.parse(savedDeck);
          socket.emit("cardgame/submitDeck", deckArray);
          $("lobby-msg").textContent = mode==='ai'?"ƒêang kh·ªüi t·∫°o game v·ªõi Bot...":"Ch·ªù ƒë·ªëi th·ªß g·ª≠i deck...";
        } else {
          alert("L·ªói: Kh√¥ng t√¨m th·∫•y deck ƒë√£ ch·ªçn!");
        }
      });

      // Deck builder drag & drop + qu·∫£n l√Ω deck
      let deckList=[];
      const submitBtn = $("submit-deck");
      let isInBotGame = false;
      const countTypes=arr=>arr.reduce((a,t)=>(a[t]++,a),{attack:0,defend:0,heal:0,curse:0});
      function refreshDeckUI(){
        const c = countTypes(deckList);
        $("cnt-attack").textContent = c.attack;
        $("cnt-defend").textContent = c.defend;
        $("cnt-heal").textContent   = c.heal;
        $("cnt-curse").textContent  = c.curse;
        $("deck-list").textContent  = deckList.join(", ");
        // Render deck cards
        const deckDrop = $("deck-drop");
        deckDrop.innerHTML = "";
        deckList.forEach((type, idx) => {
          const card = document.createElement("div");
          card.className = "cardbtn";
          card.setAttribute("data-type", type);
          card.setAttribute("draggable", "true");
          card.title = type.charAt(0).toUpperCase() + type.slice(1);
          card.ondragstart = e => {
            e.dataTransfer.setData("text/plain", idx);
            e.dataTransfer.effectAllowed = "move";
          };
          card.ondragend = e => {
            if (e.dataTransfer.dropEffect === "none") {
              deckList.splice(idx, 1);
              refreshDeckUI();
            }
          };
          deckDrop.appendChild(card);
        });
        // Hi·ªÉn th·ªã ti·∫øn ƒë·ªô & b·∫≠t/t·∫Øt n√∫t
        const remain = rules.DECK_MAX - deckList.length;
        submitBtn.disabled = remain !== 0;
        submitBtn.textContent = remain === 0
          ? "X√°c nh·∫≠n Deck (15/15)"
          : `Th√™m ${remain} l√° n·ªØa (${deckList.length}/15)`;
        // C·∫≠p nh·∫≠t danh s√°ch deck ƒë√£ l∆∞u
        updateDeckListSelect();
      }

      // Deck storage (localStorage)
      function getSavedDecks() {
        return JSON.parse(localStorage.getItem('savedDecks')||'{}');
      }
      function saveDeck(name, list) {
        if (!name) return alert('Vui l√≤ng nh·∫≠p t√™n deck!');
        const decks = getSavedDecks();
        decks[name] = list.slice();
        localStorage.setItem('savedDecks', JSON.stringify(decks));
        updateDeckListSelect();
        alert('ƒê√£ l∆∞u deck!');
      }
      function deleteDeck(name) {
        const decks = getSavedDecks();
        if (decks[name]) { delete decks[name]; localStorage.setItem('savedDecks', JSON.stringify(decks)); }
        updateDeckListSelect();
      }
      function updateDeckListSelect() {
        const decks = getSavedDecks();
        const sel = $("deck-list-select");
        const cur = sel.value;
        sel.innerHTML = '';
        Object.keys(decks).forEach(name => {
          const opt = document.createElement('option');
          opt.value = name; opt.textContent = name;
          sel.appendChild(opt);
        });
        if (cur && decks[cur]) sel.value = cur;
      }
      // N√∫t l∆∞u deck
      $("save-deck").onclick = () => {
        const name = $("deck-name").value.trim();
        if (!name) return alert('Vui l√≤ng nh·∫≠p t√™n deck!');
        if (deckList.length !== rules.DECK_MAX) return alert('Deck ph·∫£i ƒë·ªß 15 l√°!');
        saveDeck(name, deckList);
      };
      // N√∫t n·∫°p deck
      $("load-deck").onclick = () => {
        const sel = $("deck-list-select");
        const decks = getSavedDecks();
        const name = sel.value;
        if (decks[name]) {
          deckList = decks[name].slice();
          $("deck-name").value = name;
          refreshDeckUI();
        }
      };
      // N√∫t x√≥a deck
      $("delete-deck").onclick = () => {
        const sel = $("deck-list-select");
        const name = sel.value;
        if (name && confirm('X√≥a deck n√†y?')) deleteDeck(name);
      };
      // N√∫t deck m·ªõi
      $("new-deck").onclick = () => {
        deckList = [];
        $("deck-name").value = '';
        refreshDeckUI();
      };
      // Khi ch·ªçn deck trong select
      $("deck-list-select").onchange = () => {
        const sel = $("deck-list-select");
        $("deck-name").value = sel.value;
      };
      // Khi v√†o deck builder, t·ª± ƒë·ªông n·∫°p deck ƒë·∫ßu ti√™n n·∫øu c√≥
      setTimeout(()=>{
        updateDeckListSelect();
        const sel = $("deck-list-select");
        if (sel.options.length>0) {
          sel.selectedIndex = 0;
          $("load-deck").onclick();
        }
      }, 200);

      // Drag from card-samples v√†o deck-drop
      const deckDrop = $("deck-drop");
      deckDrop.ondragover = e => { e.preventDefault(); deckDrop.style.background = "#232b3e33"; };
      deckDrop.ondragleave = e => { deckDrop.style.background = ""; };
      deckDrop.ondrop = e => {
        e.preventDefault();
        deckDrop.style.background = "";
        const type = e.dataTransfer.getData("card-type");
        if (type) {
          const c = countTypes(deckList);
          if (deckList.length >= rules.DECK_MAX) return alert("ƒê·∫°t t·ªëi ƒëa 15 l√°.");
          if (c[type] >= rules.TYPE_LIMIT) return alert("M·ªói lo·∫°i t·ªëi ƒëa 6 l√°.");
          deckList.push(type);
          refreshDeckUI();
        }
      };
      // Drag c√°c l√° trong deck ra ngo√†i ƒë·ªÉ x√≥a
      deckDrop.ondragend = e => { deckDrop.style.background = ""; };

      // Drag t·ª´ card-samples
      document.querySelectorAll("#card-samples .cardbtn").forEach(btn => {
        btn.ondragstart = e => {
          e.dataTransfer.setData("card-type", btn.getAttribute("data-type"));
          e.dataTransfer.effectAllowed = "copy";
        };
      });

      $("submit-deck").onclick = () => {
        if (isInBotGame) {
          // Submit deck to server for bot game
          socket.emit("cardgame/submitDeck", deckList);
          $("lobby-msg").textContent = "ƒêang kh·ªüi t·∫°o game...";
        } else {
          // Save deck locally for later use
          sessionStorage.setItem('playerDeck', JSON.stringify(deckList));
          deck.style.display = "none";
          lobby.style.display = "";
          $("start-match").disabled = false;
          $("setup-deck").textContent = "S·ª≠a Deck";
          $("lobby-msg").textContent = "Deck ƒë√£ s·∫µn s√†ng! B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u.";
        }
      };
      socket.on("cardgame/deckError",m=>{$("deck-error").textContent=m;});
      socket.on("cardgame/deckOk",()=>{
        addEventLog("Deck ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n. B·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u!");
        deck.style.display="none";
        game.style.display="";
        
        // Hide lobby when game starts
        lobby.style.display="none";
        
        // Reset special skill state
        specialSkillActive = false;
        specialSkillUsed = false;
        updateSpecialButtonState();
        
        // Reset game state when starting new game
        last = {yhp:100, ohp:100, yshield:0, oshield:0, phase:"deckbuild", turn:0, yCurse:0, oCurse:0};
        
        // Reset UI displays for new game
        $("turn").textContent = "0";
        $("phase").textContent = "deckbuild";
        $("timer").textContent = "20s";
        $("last-played").textContent = "";
        $("reveal").innerHTML = "";
        $("you-name").textContent = "YOU";
        $("op-name").textContent = "OPPONENT";
      });

      // Game render + effects
      let myId=null, last={yhp:100, ohp:100, yshield:0, oshield:0, phase:"play", turn:0, yCurse:0, oCurse:0};
      socket.on("connect",()=>{
        myId=socket.id;
        addEventLog("K·∫øt n·ªëi th√†nh c√¥ng v·ªõi server");
      });

  function charToAvatar(ch){return ch==="Marisa"?"../assets/marisa.png":"../assets/reimu.png";}
      let turnTimer=null;
      function setTimer(s){if(turnTimer)clearInterval(turnTimer);let r=s|0;const el=$("timer");el.textContent=r+"s";turnTimer=setInterval(()=>{r=Math.max(0,r-1);el.textContent=r+"s";if(r===0)clearInterval(turnTimer);},1000);}

      function effect(container, className, ms=650){
        const n=document.createElement("div"); n.className=className; container.appendChild(n);
        setTimeout(()=>n.remove(), ms);
      }
      function setHp(sidePrefix, val, prev){
        $(sidePrefix+"-hp-text").textContent=val;
        const bar=$(sidePrefix+"-hp"); bar.style.width=Math.max(0,val)+"%";
        if(prev!==undefined && val<prev){ bar.classList.add("hp-hit"); setTimeout(()=>bar.classList.remove("hp-hit"),250); }
      }

      function iconOf(type){
        return type==="attack"?"üó°Ô∏è":type==="defend"?"üõ°Ô∏è":type==="heal"?"‚ù§Ô∏è":type==="curse"?"‚ò†Ô∏è":"‚ùî";
      }
      function buildFlip(type,label){
        const el=document.createElement("div"); el.className="flip";
        // Get card image path
        let cardImage = '';
        if (type === 'attack') cardImage = '../assets/attack.jpg';
        else if (type === 'defend') cardImage = '../assets/shield.jpg';
        else if (type === 'heal') cardImage = '../assets/heal.jpg';
        else if (type === 'curse') cardImage = '../assets/curse.jpg';
        el.innerHTML = `<div class="flip-inner">
          <div class="flip-face flip-front"></div>
          <div class="flip-face flip-back" ${cardImage ? `style="background-image: url('${cardImage}'); background-size: cover; background-position: center;"` : ''}></div>
        </div>`;
        return el;
      }

      function renderState(s){
        console.log("Rendering state - Turn:", s.turn, "Phase:", s.phase); // Debug log
        myId = s.you || myId;
        const you = s.players[myId];
        const oppId = Object.keys(s.players).find(id=>id!==myId);
        const opp = oppId ? s.players[oppId] : null;

        // === Update opponent info in PvP lobby/deck phase before game starts ===
        // Only run when still in lobby (deckbuild phase) and PvP mode
        try {
          const matchMode = window.__MATCH_MODE__ || sessionStorage.getItem('matchMode') || 'ai';
          if (matchMode === 'pvp' && (s.phase === 'deckbuild') && opp) {
            const botNameEl = document.getElementById('bot-name');
            const botAvatarEl = document.getElementById('bot-avatar');
            const botDiffEl = document.getElementById('bot-difficulty');
            const opStatusEl = document.getElementById('op-status');
            if (botNameEl) botNameEl.textContent = opp.name || 'ƒê·ªëi th·ªß';
            if (botAvatarEl) botAvatarEl.src = opp.avatar || charToAvatar(opp.character || 'Marisa');
            if (botDiffEl) { botDiffEl.textContent = 'Nh√¢n v·∫≠t: ' + (opp.character || '??'); botDiffEl.style.display = 'block'; }
            if (opStatusEl) { opStatusEl.style.display='block'; opStatusEl.textContent = opp.submitted? 'ƒê√£ s·∫µn s√†ng' : 'ƒêang ch·ªçn deck...'; }
          }
        } catch(e){ /* ignore */ }

        // Log turn changes
        if (s.turn !== last.turn) {
          addEventLog(`üéØ L∆∞·ª£t ${s.turn} - ${s.phase === 'play' ? 'Ch·ªçn b√†i' : s.phase === 'resolve' ? 'Gi·∫£i quy·∫øt' : s.phase}`);
        }

  $("you-avatar").src = you?.avatar || charToAvatar(you?.character||"Reimu");
  $("op-avatar").src  = opp?.avatar || charToAvatar(opp?.character||"Marisa");
        $("you-name").textContent = you?.name || "YOU";
        $("op-name").textContent = opp?.name || "OPPONENT";
        $("you-special-pill").className = "special-pill " + (you?.specialUsed?"special-used":"special-ready");
        $("op-special-pill").className  = "special-pill " + (opp?.specialUsed?"special-used":"");

        // Update special skill state from server
        if (you?.specialUsed && !specialSkillUsed) {
          specialSkillUsed = true;
          specialSkillActive = false;
          updateSpecialButtonState();
          addEventLog(`‚ú® B·∫°n ƒë√£ s·ª≠ d·ª•ng k·ªπ nƒÉng ƒë·∫∑c bi·ªát c·ªßa ${you.character}`);
        }

        // HP + simple deltas for effects
        const yhp=Math.max(0,you?.hp??0), ohp=Math.max(0,opp?.hp??0);
        const yshield=you?.shield??0, oshield=opp?.shield??0;

        // Log HP changes
        if(yhp < last.yhp) {
          const damage = last.yhp - yhp;
          addEventLog(`üí• B·∫°n nh·∫≠n ${damage} s√°t th∆∞∆°ng (${yhp}/${100} HP)`);
        }
        // Play sound effect for card actions (player)
        // Lu√¥n ph√°t √¢m thanh khi c√≥ th·∫ª ƒë∆∞·ª£c ch∆°i ·ªü phase resolve, k·ªÉ c·∫£ khi d√πng special ho·∫∑c hi·ªáu ·ª©ng ƒë·∫∑c bi·ªát
        if (s.phase === 'resolve') {
          // Player
          const myPlayed = s.players[myId]?.lastPlayed;
          if (myPlayed && myPlayed.card && ["attack","heal","curse","defend"].includes(myPlayed.card)) {
            try {
              playCardSound(myPlayed.card === 'defend' ? 'shield' : myPlayed.card);
            } catch (e) { console.warn('SFX error (player):', e); }
          }
          // Opponent
          const opPlayed = s.players[oppId]?.lastPlayed;
          if (opPlayed && opPlayed.card && ["attack","heal","curse","defend"].includes(opPlayed.card)) {
            try {
              playCardSound(opPlayed.card === 'defend' ? 'shield' : opPlayed.card);
            } catch (e) { console.warn('SFX error (opponent):', e); }
          }
        }
        if(yhp > last.yhp) {
          const heal = yhp - last.yhp;
          addEventLog(`üíö B·∫°n h·ªìi ${heal} HP (${yhp}/${100} HP)`);
        }
        if(ohp < last.ohp) {
          const damage = last.ohp - ohp;
          addEventLog(`‚öîÔ∏è ƒê·ªëi th·ªß nh·∫≠n ${damage} s√°t th∆∞∆°ng (${ohp}/${100} HP)`);
        }
        if(ohp > last.ohp) {
          const heal = ohp - last.ohp;
          addEventLog(`ü©π ƒê·ªëi th·ªß h·ªìi ${heal} HP (${ohp}/${100} HP)`);
        }

        // Log shield changes
        if(yshield > last.yshield) {
          const shieldGain = yshield - last.yshield;
          addEventLog(`üõ°Ô∏è B·∫°n ƒë∆∞·ª£c ${shieldGain} khi√™n (T·ªïng: ${yshield})`);
        }
        if(oshield > last.oshield) {
          const shieldGain = oshield - last.oshield;
          addEventLog(`üî∞ ƒê·ªëi th·ªß ƒë∆∞·ª£c ${shieldGain} khi√™n (T·ªïng: ${oshield})`);
        }

        // Log status effects
        if(you?.curseTurns && you.curseTurns !== last.yCurse) {
          if(you.curseTurns > 0) {
            addEventLog(`üòà B·∫°n b·ªã nguy·ªÅn r·ªßa (${you.curseTurns} l∆∞·ª£t c√≤n l·∫°i)`);
          } else if(last.yCurse > 0) {
            addEventLog(`‚ú® L·ªùi nguy·ªÅn c·ªßa b·∫°n ƒë√£ h·∫øt`);
          }
        }
        if(opp?.curseTurns && opp.curseTurns !== last.oCurse) {
          if(opp.curseTurns > 0) {
            addEventLog(`üåü ƒê·ªëi th·ªß b·ªã nguy·ªÅn r·ªßa (${opp.curseTurns} l∆∞·ª£t c√≤n l·∫°i)`);
          } else if(last.oCurse > 0) {
            addEventLog(`üî• L·ªùi nguy·ªÅn ƒë·ªëi th·ªß ƒë√£ h·∫øt`);
          }
        }

        // Damage / Heal detection
        if(yhp<last.yhp){ $("you-side").classList.add("damage-flash"); setTimeout(()=>$("you-side").classList.remove("damage-flash"),350); }
        if(ohp<last.ohp){ $("op-side").classList.add("damage-flash"); setTimeout(()=>$("op-side").classList.remove("damage-flash"),350); }
        if(yhp>last.yhp){ effect($("you-side"),"heal-spark",700); }
        if(ohp>last.ohp){ effect($("op-side"),"heal-spark",700); }
        if(yshield>last.yshield){ effect($("you-side"),"shield-pop",600); }
        if(oshield>last.oshield){ effect($("op-side"),"shield-pop",600); }

        setHp("you", yhp, last.yhp); setHp("op", ohp, last.ohp);
        $("you-shield").textContent=yshield; $("op-shield").textContent=oshield;

        $("turn").textContent=s.turn; $("phase").textContent=s.phase; setTimer(s.timerRemaining??0);

        // Last played text
        const lp=[]; for(const [pid,info] of Object.entries(s.players)){ if(info.lastPlayed) lp.push(`${pid===myId?"B·∫°n":"ƒê·ªëi th·ªß"}: ${info.lastPlayed.note}`); }
        $("last-played").textContent = lp.join(" | ");

        // Opponent backs count ‚âà s·ªë l√° tr√™n tay m√¨nh
        const oppBacks=$("opp-backs"); oppBacks.innerHTML="";
        const c=(s.hand||[]).length||5; for(let i=0;i<c;i++){ const d=document.createElement("div"); d.className="back"; oppBacks.appendChild(d); }

        // Render my hand
        const hand=$("hand"); hand.innerHTML="";
        (s.hand||[]).forEach((type,idx)=>{
          const b=document.createElement("button"); b.className="cardbtn"; b.dataset.type=type;
          b.onclick=()=>{ 
            const useSpecial = specialSkillActive && !specialSkillUsed;
            if (useSpecial) {
              specialSkillUsed = true;
              specialSkillActive = false;
              updateSpecialButtonState();
              addEventLog(`üåü Ch·ªçn l√° b√†i ${type} v·ªõi k·ªπ nƒÉng ƒë·∫∑c bi·ªát`);
            } else {
              addEventLog(`üìã Ch·ªçn l√° b√†i ${type}`);
            }
            socket.emit("cardgame/play",{cardIndex:idx,useSpecial}); 
          };
          hand.appendChild(b);
        });
        $("deck-meta").textContent = you?.submitted ? "B·∫°n ƒë√£ g·ª≠i l·ª±a ch·ªçn l∆∞·ª£t n√†y." : "";

        // ===== Flip reveal when phase changes to resolve =====
        const rev=$("reveal");
        if(s.phase==="resolve"){
          // Find the two lastPlayed cards
          const mine = s.players[myId]?.lastPlayed?.card;
          const ops  = s.players[oppId]?.lastPlayed?.card;
          
          // Log card plays
          if(mine && mine !== "‚ùå") {
            const myNote = s.players[myId]?.lastPlayed?.note || mine;
            addEventLog(`üÉè B·∫°n ch∆°i: ${myNote}`);
          }
          if(ops && ops !== "‚ùå") {
            const opNote = s.players[oppId]?.lastPlayed?.note || ops;
            addEventLog(`üé¥ ƒê·ªëi th·ªß ch∆°i: ${opNote}`);
          }
          
          rev.innerHTML="";
          // build flip cards even if one side didn't play
          const mineFlip = buildFlip(mine||"‚ùå", "");
          const opFlip   = buildFlip(ops||"‚ùå", "");
          rev.appendChild(mineFlip); rev.appendChild(opFlip);
          // trigger flip after a tick
          setTimeout(()=>{ mineFlip.classList.add("flipped"); opFlip.classList.add("flipped"); },40);
        }else{
          rev.innerHTML="";
        }

        // save last state including curse info
        last={
          yhp, ohp, yshield, oshield, 
          phase: s.phase, 
          turn: s.turn,
          yCurse: you?.curseTurns || 0,
          oCurse: opp?.curseTurns || 0
        };
      }

      socket.on("cardgame/state", (s) => {
        console.log("Received game state:", s); // Debug log
        renderState(s);
      });

      socket.on("cardgame/submitted",({player})=>{
        if(player===myId){ $("you-special-pill").classList.add("pulse"); setTimeout(()=>$("you-special-pill").classList.remove("pulse"),800); }
      });

      socket.on("cardgame/end",(result)=>{
        let resultType = "";
        let title = "";
        let details = "";
        
        if(result?.reason==="opponent_left"){ 
          resultType = "win";
          title = "CHI·∫æN TH·∫ÆNG!";
          details = "ƒê·ªëi th·ªß ƒë√£ r·ªùi kh·ªèi tr·∫≠n ƒë·∫•u";
          addEventLog("ƒê·ªëi th·ªß r·ªùi kh·ªèi tr·∫≠n ƒë·∫•u");
          
          // Show result overlay
          showGameResult(resultType, title, details, 100, 0, result.turn || 1);
        }
        else{
          const a=result.a,b=result.b; const my=(a.id===myId)?a:b, op=(a.id===myId)?b:a;
          
          if(my.hp>op.hp) {
            resultType = "win";
            title = "CHI·∫æN TH·∫ÆNG!";
            details = `Xu·∫•t s·∫Øc! B·∫°n ƒë√£ gi√†nh chi·∫øn th·∫Øng sau ${result.turn} l∆∞·ª£t.`;
            addEventLog(`üéâ CHI·∫æN TH·∫ÆNG! K·∫øt th√∫c l∆∞·ª£t ${result.turn} (${my.hp} vs ${op.hp})`);
          } else if(my.hp<op.hp) {
            resultType = "lose";
            title = "TH·∫§T B·∫†I";
            details = `Ti·∫øc qu√°! B·∫°n ƒë√£ thua sau ${result.turn} l∆∞·ª£t.`;
            addEventLog(`üòû Th·∫•t b·∫°i. K·∫øt th√∫c l∆∞·ª£t ${result.turn} (${my.hp} vs ${op.hp})`);
          } else {
            resultType = "draw";
            title = "H√íA";
            details = `Tr·∫≠n ƒë·∫•u k·∫øt th√∫c h√≤a sau ${result.turn} l∆∞·ª£t.`;
            addEventLog(`ü§ù H√≤a. K·∫øt th√∫c l∆∞·ª£t ${result.turn} (${my.hp} vs ${op.hp})`);
          }
          
          // Show result overlay
          showGameResult(resultType, title, details, my.hp, op.hp, result.turn);
        }
      });
      
      // Function to show game result overlay
      function showGameResult(type, title, details, yourHp, opHp, turn) {
        // Play result sound
        if (window.playGameResultSound) {
          window.playGameResultSound(type);
        }
        
        const overlay = $("game-result-overlay");
        const titleEl = $("result-title");
        const detailsEl = $("result-details");
        const yourHpEl = $("your-final-hp");
        const opHpEl = $("op-final-hp");
        const turnEl = $("final-turn");
        
        // Update content
        titleEl.textContent = title;
        titleEl.className = `result-title ${type}`;
        detailsEl.textContent = details;
        yourHpEl.textContent = yourHp;
        opHpEl.textContent = opHp;
        turnEl.textContent = turn;
        
        // Show overlay
        overlay.style.display = "flex";
        
        // Setup button handlers
        const playAgainBtn = $("play-again-btn");
        const backToMenuBtn = $("back-to-menu-btn");
        
        playAgainBtn.onclick = () => {
          overlay.style.display = "none";
          resetToLobby();
        };
        
        backToMenuBtn.onclick = () => {
          overlay.style.display = "none";
          window.location.href = '/main_menu.html';
        };
      }
      
      // Function to reset game to lobby
      function resetToLobby() {
        game.style.display = "none";
        deck.style.display = "none";
        lobby.style.display = "";
        $("lobby-msg").textContent = "";
        deckList.length = 0;
        refreshDeckUI();
        
        // Leave any existing card game rooms
        socket.rooms.forEach(roomId => {
          if (roomId.startsWith('cardgame-') || roomId.startsWith('airoom-')) {
            socket.leave(roomId);
            console.log('Left room:', roomId);
          }
        });
        
        // Reset game state variables
        myId = null;
        last = {yhp:100, ohp:100, yshield:0, oshield:0, phase:"play", turn:0, yCurse:0, oCurse:0};
        isInBotGame = false;
        
        // Reset special skill state
        specialSkillActive = false;
        specialSkillUsed = false;
        updateSpecialButtonState();
        
        // Reset UI elements
        $("turn").textContent = "1";
        $("phase").textContent = "deckbuild";
        $("timer").textContent = "20s";
        $("last-played").textContent = "";
        $("reveal").innerHTML = "";
        
        // Clear event log and chat for fresh start
        const eventMessages = document.getElementById('event-messages');
        if (eventMessages) eventMessages.innerHTML = '';
        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) chatMessages.innerHTML = '';
        
        // Reset start match button
        $("start-match").disabled = !$("deck-selector").value;
        $("setup-deck").textContent = "X·∫øp Deck";
        
        // Add fresh start message
        addEventLog('S·∫µn s√†ng cho tr·∫≠n ƒë·∫•u m·ªõi');
        addChatMessage('System', 'Ch√†o m·ª´ng tr·ªü l·∫°i!');
      }

      // Sidebar functionality
      function initSidebar() {
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            const targetTab = btn.dataset.tab;
            
            // Remove active class from all tabs and buttons
            tabBtns.forEach(b => b.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Add active class to clicked button and corresponding content
            btn.classList.add('active');
            document.getElementById(targetTab + '-tab').classList.add('active');
          });
        });
        
        // Chat input functionality
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-chat');
        
        function sendMessage() {
          const message = chatInput.value.trim();
          if (message) {
            addChatMessage('B·∫°n', message);
            chatInput.value = '';
          }
        }
        
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            sendMessage();
          }
        });
      }
      
      // Chat and Event Log functions
      function addChatMessage(sender, text) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        
        const timestamp = new Date().toLocaleTimeString('vi-VN', {
          hour: '2-digit',
          minute: '2-digit'
        });
        
        messageDiv.innerHTML = `
          <div class="message-header">
            <span class="sender">${sender}</span>
            <span class="timestamp">${timestamp}</span>
          </div>
          <div class="message-text">${text}</div>
        `;
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      function addEventLog(text) {
        const eventMessages = document.getElementById('event-messages');
        const eventDiv = document.createElement('div');
        eventDiv.className = 'event';
        
        const timestamp = new Date().toLocaleTimeString('vi-VN', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
        
        eventDiv.innerHTML = `
          <div class="event-timestamp">${timestamp}</div>
          <div class="event-text">${text}</div>
        `;
        
        eventMessages.appendChild(eventDiv);
        eventMessages.scrollTop = eventMessages.scrollHeight;
      }
      
      // Initialize sidebar when page loads
      // (Already initialized in window.onload above)
    </script>
    </div> <!-- Close main-content -->
  </body>
</html>